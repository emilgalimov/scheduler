package app

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/emilgalimov/homework-2/internal/app.Repository -o ./internal/app/repository_mock_test.go -n RepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/emilgalimov/homework-2/internal/models"
)

// RepositoryMock implements Repository
type RepositoryMock struct {
	t minimock.Tester

	funcCreateTask          func(ctx context.Context, t1 models.Task) (u1 uint64, err error)
	inspectFuncCreateTask   func(ctx context.Context, t1 models.Task)
	afterCreateTaskCounter  uint64
	beforeCreateTaskCounter uint64
	CreateTaskMock          mRepositoryMockCreateTask

	funcCreateTaskStage          func(ctx context.Context, taskStage models.TaskStage, taskID uint64) (u1 uint64, err error)
	inspectFuncCreateTaskStage   func(ctx context.Context, taskStage models.TaskStage, taskID uint64)
	afterCreateTaskStageCounter  uint64
	beforeCreateTaskStageCounter uint64
	CreateTaskStageMock          mRepositoryMockCreateTaskStage

	funcCreateUser          func(ctx context.Context) (u1 uint64, err error)
	inspectFuncCreateUser   func(ctx context.Context)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mRepositoryMockCreateUser

	funcCreateUserTask          func(ctx context.Context, userID uint64, taskID uint64) (err error)
	inspectFuncCreateUserTask   func(ctx context.Context, userID uint64, taskID uint64)
	afterCreateUserTaskCounter  uint64
	beforeCreateUserTaskCounter uint64
	CreateUserTaskMock          mRepositoryMockCreateUserTask

	funcDeleteUserTask          func(ctx context.Context, userID uint64, taskID uint64) (err error)
	inspectFuncDeleteUserTask   func(ctx context.Context, userID uint64, taskID uint64)
	afterDeleteUserTaskCounter  uint64
	beforeDeleteUserTaskCounter uint64
	DeleteUserTaskMock          mRepositoryMockDeleteUserTask

	funcGetAllTasks          func(ctx context.Context) (tpa1 []*models.Task, err error)
	inspectFuncGetAllTasks   func(ctx context.Context)
	afterGetAllTasksCounter  uint64
	beforeGetAllTasksCounter uint64
	GetAllTasksMock          mRepositoryMockGetAllTasks

	funcGetTask          func(ctx context.Context, ID uint64) (tp1 *models.Task, err error)
	inspectFuncGetTask   func(ctx context.Context, ID uint64)
	afterGetTaskCounter  uint64
	beforeGetTaskCounter uint64
	GetTaskMock          mRepositoryMockGetTask

	funcGetUserTask          func(ctx context.Context, userID uint64, taskID uint64) (up1 *models.UserTask, err error)
	inspectFuncGetUserTask   func(ctx context.Context, userID uint64, taskID uint64)
	afterGetUserTaskCounter  uint64
	beforeGetUserTaskCounter uint64
	GetUserTaskMock          mRepositoryMockGetUserTask
}

// NewRepositoryMock returns a mock for Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateTaskMock = mRepositoryMockCreateTask{mock: m}
	m.CreateTaskMock.callArgs = []*RepositoryMockCreateTaskParams{}

	m.CreateTaskStageMock = mRepositoryMockCreateTaskStage{mock: m}
	m.CreateTaskStageMock.callArgs = []*RepositoryMockCreateTaskStageParams{}

	m.CreateUserMock = mRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*RepositoryMockCreateUserParams{}

	m.CreateUserTaskMock = mRepositoryMockCreateUserTask{mock: m}
	m.CreateUserTaskMock.callArgs = []*RepositoryMockCreateUserTaskParams{}

	m.DeleteUserTaskMock = mRepositoryMockDeleteUserTask{mock: m}
	m.DeleteUserTaskMock.callArgs = []*RepositoryMockDeleteUserTaskParams{}

	m.GetAllTasksMock = mRepositoryMockGetAllTasks{mock: m}
	m.GetAllTasksMock.callArgs = []*RepositoryMockGetAllTasksParams{}

	m.GetTaskMock = mRepositoryMockGetTask{mock: m}
	m.GetTaskMock.callArgs = []*RepositoryMockGetTaskParams{}

	m.GetUserTaskMock = mRepositoryMockGetUserTask{mock: m}
	m.GetUserTaskMock.callArgs = []*RepositoryMockGetUserTaskParams{}

	return m
}

type mRepositoryMockCreateTask struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateTaskExpectation
	expectations       []*RepositoryMockCreateTaskExpectation

	callArgs []*RepositoryMockCreateTaskParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateTaskExpectation specifies expectation struct of the Repository.CreateTask
type RepositoryMockCreateTaskExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateTaskParams
	results *RepositoryMockCreateTaskResults
	Counter uint64
}

// RepositoryMockCreateTaskParams contains parameters of the Repository.CreateTask
type RepositoryMockCreateTaskParams struct {
	ctx context.Context
	t1  models.Task
}

// RepositoryMockCreateTaskResults contains results of the Repository.CreateTask
type RepositoryMockCreateTaskResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for Repository.CreateTask
func (mmCreateTask *mRepositoryMockCreateTask) Expect(ctx context.Context, t1 models.Task) *mRepositoryMockCreateTask {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("RepositoryMock.CreateTask mock is already set by Set")
	}

	if mmCreateTask.defaultExpectation == nil {
		mmCreateTask.defaultExpectation = &RepositoryMockCreateTaskExpectation{}
	}

	mmCreateTask.defaultExpectation.params = &RepositoryMockCreateTaskParams{ctx, t1}
	for _, e := range mmCreateTask.expectations {
		if minimock.Equal(e.params, mmCreateTask.defaultExpectation.params) {
			mmCreateTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTask.defaultExpectation.params)
		}
	}

	return mmCreateTask
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateTask
func (mmCreateTask *mRepositoryMockCreateTask) Inspect(f func(ctx context.Context, t1 models.Task)) *mRepositoryMockCreateTask {
	if mmCreateTask.mock.inspectFuncCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateTask")
	}

	mmCreateTask.mock.inspectFuncCreateTask = f

	return mmCreateTask
}

// Return sets up results that will be returned by Repository.CreateTask
func (mmCreateTask *mRepositoryMockCreateTask) Return(u1 uint64, err error) *RepositoryMock {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("RepositoryMock.CreateTask mock is already set by Set")
	}

	if mmCreateTask.defaultExpectation == nil {
		mmCreateTask.defaultExpectation = &RepositoryMockCreateTaskExpectation{mock: mmCreateTask.mock}
	}
	mmCreateTask.defaultExpectation.results = &RepositoryMockCreateTaskResults{u1, err}
	return mmCreateTask.mock
}

//Set uses given function f to mock the Repository.CreateTask method
func (mmCreateTask *mRepositoryMockCreateTask) Set(f func(ctx context.Context, t1 models.Task) (u1 uint64, err error)) *RepositoryMock {
	if mmCreateTask.defaultExpectation != nil {
		mmCreateTask.mock.t.Fatalf("Default expectation is already set for the Repository.CreateTask method")
	}

	if len(mmCreateTask.expectations) > 0 {
		mmCreateTask.mock.t.Fatalf("Some expectations are already set for the Repository.CreateTask method")
	}

	mmCreateTask.mock.funcCreateTask = f
	return mmCreateTask.mock
}

// When sets expectation for the Repository.CreateTask which will trigger the result defined by the following
// Then helper
func (mmCreateTask *mRepositoryMockCreateTask) When(ctx context.Context, t1 models.Task) *RepositoryMockCreateTaskExpectation {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("RepositoryMock.CreateTask mock is already set by Set")
	}

	expectation := &RepositoryMockCreateTaskExpectation{
		mock:   mmCreateTask.mock,
		params: &RepositoryMockCreateTaskParams{ctx, t1},
	}
	mmCreateTask.expectations = append(mmCreateTask.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateTask return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateTaskExpectation) Then(u1 uint64, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateTaskResults{u1, err}
	return e.mock
}

// CreateTask implements Repository
func (mmCreateTask *RepositoryMock) CreateTask(ctx context.Context, t1 models.Task) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmCreateTask.beforeCreateTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTask.afterCreateTaskCounter, 1)

	if mmCreateTask.inspectFuncCreateTask != nil {
		mmCreateTask.inspectFuncCreateTask(ctx, t1)
	}

	mm_params := &RepositoryMockCreateTaskParams{ctx, t1}

	// Record call args
	mmCreateTask.CreateTaskMock.mutex.Lock()
	mmCreateTask.CreateTaskMock.callArgs = append(mmCreateTask.CreateTaskMock.callArgs, mm_params)
	mmCreateTask.CreateTaskMock.mutex.Unlock()

	for _, e := range mmCreateTask.CreateTaskMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreateTask.CreateTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTask.CreateTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTask.CreateTaskMock.defaultExpectation.params
		mm_got := RepositoryMockCreateTaskParams{ctx, t1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTask.t.Errorf("RepositoryMock.CreateTask got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTask.CreateTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTask.t.Fatal("No results are set for the RepositoryMock.CreateTask")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreateTask.funcCreateTask != nil {
		return mmCreateTask.funcCreateTask(ctx, t1)
	}
	mmCreateTask.t.Fatalf("Unexpected call to RepositoryMock.CreateTask. %v %v", ctx, t1)
	return
}

// CreateTaskAfterCounter returns a count of finished RepositoryMock.CreateTask invocations
func (mmCreateTask *RepositoryMock) CreateTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTask.afterCreateTaskCounter)
}

// CreateTaskBeforeCounter returns a count of RepositoryMock.CreateTask invocations
func (mmCreateTask *RepositoryMock) CreateTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTask.beforeCreateTaskCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTask *mRepositoryMockCreateTask) Calls() []*RepositoryMockCreateTaskParams {
	mmCreateTask.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateTaskParams, len(mmCreateTask.callArgs))
	copy(argCopy, mmCreateTask.callArgs)

	mmCreateTask.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTaskDone returns true if the count of the CreateTask invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateTaskDone() bool {
	for _, e := range m.CreateTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateTaskCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTask != nil && mm_atomic.LoadUint64(&m.afterCreateTaskCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateTaskInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateTaskInspect() {
	for _, e := range m.CreateTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateTask with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateTaskCounter) < 1 {
		if m.CreateTaskMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateTask")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateTask with params: %#v", *m.CreateTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTask != nil && mm_atomic.LoadUint64(&m.afterCreateTaskCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateTask")
	}
}

type mRepositoryMockCreateTaskStage struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateTaskStageExpectation
	expectations       []*RepositoryMockCreateTaskStageExpectation

	callArgs []*RepositoryMockCreateTaskStageParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateTaskStageExpectation specifies expectation struct of the Repository.CreateTaskStage
type RepositoryMockCreateTaskStageExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateTaskStageParams
	results *RepositoryMockCreateTaskStageResults
	Counter uint64
}

// RepositoryMockCreateTaskStageParams contains parameters of the Repository.CreateTaskStage
type RepositoryMockCreateTaskStageParams struct {
	ctx       context.Context
	taskStage models.TaskStage
	taskID    uint64
}

// RepositoryMockCreateTaskStageResults contains results of the Repository.CreateTaskStage
type RepositoryMockCreateTaskStageResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for Repository.CreateTaskStage
func (mmCreateTaskStage *mRepositoryMockCreateTaskStage) Expect(ctx context.Context, taskStage models.TaskStage, taskID uint64) *mRepositoryMockCreateTaskStage {
	if mmCreateTaskStage.mock.funcCreateTaskStage != nil {
		mmCreateTaskStage.mock.t.Fatalf("RepositoryMock.CreateTaskStage mock is already set by Set")
	}

	if mmCreateTaskStage.defaultExpectation == nil {
		mmCreateTaskStage.defaultExpectation = &RepositoryMockCreateTaskStageExpectation{}
	}

	mmCreateTaskStage.defaultExpectation.params = &RepositoryMockCreateTaskStageParams{ctx, taskStage, taskID}
	for _, e := range mmCreateTaskStage.expectations {
		if minimock.Equal(e.params, mmCreateTaskStage.defaultExpectation.params) {
			mmCreateTaskStage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTaskStage.defaultExpectation.params)
		}
	}

	return mmCreateTaskStage
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateTaskStage
func (mmCreateTaskStage *mRepositoryMockCreateTaskStage) Inspect(f func(ctx context.Context, taskStage models.TaskStage, taskID uint64)) *mRepositoryMockCreateTaskStage {
	if mmCreateTaskStage.mock.inspectFuncCreateTaskStage != nil {
		mmCreateTaskStage.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateTaskStage")
	}

	mmCreateTaskStage.mock.inspectFuncCreateTaskStage = f

	return mmCreateTaskStage
}

// Return sets up results that will be returned by Repository.CreateTaskStage
func (mmCreateTaskStage *mRepositoryMockCreateTaskStage) Return(u1 uint64, err error) *RepositoryMock {
	if mmCreateTaskStage.mock.funcCreateTaskStage != nil {
		mmCreateTaskStage.mock.t.Fatalf("RepositoryMock.CreateTaskStage mock is already set by Set")
	}

	if mmCreateTaskStage.defaultExpectation == nil {
		mmCreateTaskStage.defaultExpectation = &RepositoryMockCreateTaskStageExpectation{mock: mmCreateTaskStage.mock}
	}
	mmCreateTaskStage.defaultExpectation.results = &RepositoryMockCreateTaskStageResults{u1, err}
	return mmCreateTaskStage.mock
}

//Set uses given function f to mock the Repository.CreateTaskStage method
func (mmCreateTaskStage *mRepositoryMockCreateTaskStage) Set(f func(ctx context.Context, taskStage models.TaskStage, taskID uint64) (u1 uint64, err error)) *RepositoryMock {
	if mmCreateTaskStage.defaultExpectation != nil {
		mmCreateTaskStage.mock.t.Fatalf("Default expectation is already set for the Repository.CreateTaskStage method")
	}

	if len(mmCreateTaskStage.expectations) > 0 {
		mmCreateTaskStage.mock.t.Fatalf("Some expectations are already set for the Repository.CreateTaskStage method")
	}

	mmCreateTaskStage.mock.funcCreateTaskStage = f
	return mmCreateTaskStage.mock
}

// When sets expectation for the Repository.CreateTaskStage which will trigger the result defined by the following
// Then helper
func (mmCreateTaskStage *mRepositoryMockCreateTaskStage) When(ctx context.Context, taskStage models.TaskStage, taskID uint64) *RepositoryMockCreateTaskStageExpectation {
	if mmCreateTaskStage.mock.funcCreateTaskStage != nil {
		mmCreateTaskStage.mock.t.Fatalf("RepositoryMock.CreateTaskStage mock is already set by Set")
	}

	expectation := &RepositoryMockCreateTaskStageExpectation{
		mock:   mmCreateTaskStage.mock,
		params: &RepositoryMockCreateTaskStageParams{ctx, taskStage, taskID},
	}
	mmCreateTaskStage.expectations = append(mmCreateTaskStage.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateTaskStage return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateTaskStageExpectation) Then(u1 uint64, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateTaskStageResults{u1, err}
	return e.mock
}

// CreateTaskStage implements Repository
func (mmCreateTaskStage *RepositoryMock) CreateTaskStage(ctx context.Context, taskStage models.TaskStage, taskID uint64) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmCreateTaskStage.beforeCreateTaskStageCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTaskStage.afterCreateTaskStageCounter, 1)

	if mmCreateTaskStage.inspectFuncCreateTaskStage != nil {
		mmCreateTaskStage.inspectFuncCreateTaskStage(ctx, taskStage, taskID)
	}

	mm_params := &RepositoryMockCreateTaskStageParams{ctx, taskStage, taskID}

	// Record call args
	mmCreateTaskStage.CreateTaskStageMock.mutex.Lock()
	mmCreateTaskStage.CreateTaskStageMock.callArgs = append(mmCreateTaskStage.CreateTaskStageMock.callArgs, mm_params)
	mmCreateTaskStage.CreateTaskStageMock.mutex.Unlock()

	for _, e := range mmCreateTaskStage.CreateTaskStageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreateTaskStage.CreateTaskStageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTaskStage.CreateTaskStageMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTaskStage.CreateTaskStageMock.defaultExpectation.params
		mm_got := RepositoryMockCreateTaskStageParams{ctx, taskStage, taskID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTaskStage.t.Errorf("RepositoryMock.CreateTaskStage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTaskStage.CreateTaskStageMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTaskStage.t.Fatal("No results are set for the RepositoryMock.CreateTaskStage")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreateTaskStage.funcCreateTaskStage != nil {
		return mmCreateTaskStage.funcCreateTaskStage(ctx, taskStage, taskID)
	}
	mmCreateTaskStage.t.Fatalf("Unexpected call to RepositoryMock.CreateTaskStage. %v %v %v", ctx, taskStage, taskID)
	return
}

// CreateTaskStageAfterCounter returns a count of finished RepositoryMock.CreateTaskStage invocations
func (mmCreateTaskStage *RepositoryMock) CreateTaskStageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTaskStage.afterCreateTaskStageCounter)
}

// CreateTaskStageBeforeCounter returns a count of RepositoryMock.CreateTaskStage invocations
func (mmCreateTaskStage *RepositoryMock) CreateTaskStageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTaskStage.beforeCreateTaskStageCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateTaskStage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTaskStage *mRepositoryMockCreateTaskStage) Calls() []*RepositoryMockCreateTaskStageParams {
	mmCreateTaskStage.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateTaskStageParams, len(mmCreateTaskStage.callArgs))
	copy(argCopy, mmCreateTaskStage.callArgs)

	mmCreateTaskStage.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTaskStageDone returns true if the count of the CreateTaskStage invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateTaskStageDone() bool {
	for _, e := range m.CreateTaskStageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTaskStageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateTaskStageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTaskStage != nil && mm_atomic.LoadUint64(&m.afterCreateTaskStageCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateTaskStageInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateTaskStageInspect() {
	for _, e := range m.CreateTaskStageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateTaskStage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTaskStageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateTaskStageCounter) < 1 {
		if m.CreateTaskStageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateTaskStage")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateTaskStage with params: %#v", *m.CreateTaskStageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTaskStage != nil && mm_atomic.LoadUint64(&m.afterCreateTaskStageCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateTaskStage")
	}
}

type mRepositoryMockCreateUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateUserExpectation
	expectations       []*RepositoryMockCreateUserExpectation

	callArgs []*RepositoryMockCreateUserParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateUserExpectation specifies expectation struct of the Repository.CreateUser
type RepositoryMockCreateUserExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateUserParams
	results *RepositoryMockCreateUserResults
	Counter uint64
}

// RepositoryMockCreateUserParams contains parameters of the Repository.CreateUser
type RepositoryMockCreateUserParams struct {
	ctx context.Context
}

// RepositoryMockCreateUserResults contains results of the Repository.CreateUser
type RepositoryMockCreateUserResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Expect(ctx context.Context) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{}
	}

	mmCreateUser.defaultExpectation.params = &RepositoryMockCreateUserParams{ctx}
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Inspect(f func(ctx context.Context)) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Return(u1 uint64, err error) *RepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &RepositoryMockCreateUserResults{u1, err}
	return mmCreateUser.mock
}

//Set uses given function f to mock the Repository.CreateUser method
func (mmCreateUser *mRepositoryMockCreateUser) Set(f func(ctx context.Context) (u1 uint64, err error)) *RepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the Repository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the Repository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	return mmCreateUser.mock
}

// When sets expectation for the Repository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mRepositoryMockCreateUser) When(ctx context.Context) *RepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &RepositoryMockCreateUserExpectation{
		mock:   mmCreateUser.mock,
		params: &RepositoryMockCreateUserParams{ctx},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateUserExpectation) Then(u1 uint64, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateUserResults{u1, err}
	return e.mock
}

// CreateUser implements Repository
func (mmCreateUser *RepositoryMock) CreateUser(ctx context.Context) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx)
	}

	mm_params := &RepositoryMockCreateUserParams{ctx}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_got := RepositoryMockCreateUserParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("RepositoryMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the RepositoryMock.CreateUser")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx)
	}
	mmCreateUser.t.Fatalf("Unexpected call to RepositoryMock.CreateUser. %v", ctx)
	return
}

// CreateUserAfterCounter returns a count of finished RepositoryMock.CreateUser invocations
func (mmCreateUser *RepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of RepositoryMock.CreateUser invocations
func (mmCreateUser *RepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mRepositoryMockCreateUser) Calls() []*RepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateUserDone() bool {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateUser")
	}
}

type mRepositoryMockCreateUserTask struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateUserTaskExpectation
	expectations       []*RepositoryMockCreateUserTaskExpectation

	callArgs []*RepositoryMockCreateUserTaskParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateUserTaskExpectation specifies expectation struct of the Repository.CreateUserTask
type RepositoryMockCreateUserTaskExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateUserTaskParams
	results *RepositoryMockCreateUserTaskResults
	Counter uint64
}

// RepositoryMockCreateUserTaskParams contains parameters of the Repository.CreateUserTask
type RepositoryMockCreateUserTaskParams struct {
	ctx    context.Context
	userID uint64
	taskID uint64
}

// RepositoryMockCreateUserTaskResults contains results of the Repository.CreateUserTask
type RepositoryMockCreateUserTaskResults struct {
	err error
}

// Expect sets up expected params for Repository.CreateUserTask
func (mmCreateUserTask *mRepositoryMockCreateUserTask) Expect(ctx context.Context, userID uint64, taskID uint64) *mRepositoryMockCreateUserTask {
	if mmCreateUserTask.mock.funcCreateUserTask != nil {
		mmCreateUserTask.mock.t.Fatalf("RepositoryMock.CreateUserTask mock is already set by Set")
	}

	if mmCreateUserTask.defaultExpectation == nil {
		mmCreateUserTask.defaultExpectation = &RepositoryMockCreateUserTaskExpectation{}
	}

	mmCreateUserTask.defaultExpectation.params = &RepositoryMockCreateUserTaskParams{ctx, userID, taskID}
	for _, e := range mmCreateUserTask.expectations {
		if minimock.Equal(e.params, mmCreateUserTask.defaultExpectation.params) {
			mmCreateUserTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUserTask.defaultExpectation.params)
		}
	}

	return mmCreateUserTask
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateUserTask
func (mmCreateUserTask *mRepositoryMockCreateUserTask) Inspect(f func(ctx context.Context, userID uint64, taskID uint64)) *mRepositoryMockCreateUserTask {
	if mmCreateUserTask.mock.inspectFuncCreateUserTask != nil {
		mmCreateUserTask.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateUserTask")
	}

	mmCreateUserTask.mock.inspectFuncCreateUserTask = f

	return mmCreateUserTask
}

// Return sets up results that will be returned by Repository.CreateUserTask
func (mmCreateUserTask *mRepositoryMockCreateUserTask) Return(err error) *RepositoryMock {
	if mmCreateUserTask.mock.funcCreateUserTask != nil {
		mmCreateUserTask.mock.t.Fatalf("RepositoryMock.CreateUserTask mock is already set by Set")
	}

	if mmCreateUserTask.defaultExpectation == nil {
		mmCreateUserTask.defaultExpectation = &RepositoryMockCreateUserTaskExpectation{mock: mmCreateUserTask.mock}
	}
	mmCreateUserTask.defaultExpectation.results = &RepositoryMockCreateUserTaskResults{err}
	return mmCreateUserTask.mock
}

//Set uses given function f to mock the Repository.CreateUserTask method
func (mmCreateUserTask *mRepositoryMockCreateUserTask) Set(f func(ctx context.Context, userID uint64, taskID uint64) (err error)) *RepositoryMock {
	if mmCreateUserTask.defaultExpectation != nil {
		mmCreateUserTask.mock.t.Fatalf("Default expectation is already set for the Repository.CreateUserTask method")
	}

	if len(mmCreateUserTask.expectations) > 0 {
		mmCreateUserTask.mock.t.Fatalf("Some expectations are already set for the Repository.CreateUserTask method")
	}

	mmCreateUserTask.mock.funcCreateUserTask = f
	return mmCreateUserTask.mock
}

// When sets expectation for the Repository.CreateUserTask which will trigger the result defined by the following
// Then helper
func (mmCreateUserTask *mRepositoryMockCreateUserTask) When(ctx context.Context, userID uint64, taskID uint64) *RepositoryMockCreateUserTaskExpectation {
	if mmCreateUserTask.mock.funcCreateUserTask != nil {
		mmCreateUserTask.mock.t.Fatalf("RepositoryMock.CreateUserTask mock is already set by Set")
	}

	expectation := &RepositoryMockCreateUserTaskExpectation{
		mock:   mmCreateUserTask.mock,
		params: &RepositoryMockCreateUserTaskParams{ctx, userID, taskID},
	}
	mmCreateUserTask.expectations = append(mmCreateUserTask.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateUserTask return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateUserTaskExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateUserTaskResults{err}
	return e.mock
}

// CreateUserTask implements Repository
func (mmCreateUserTask *RepositoryMock) CreateUserTask(ctx context.Context, userID uint64, taskID uint64) (err error) {
	mm_atomic.AddUint64(&mmCreateUserTask.beforeCreateUserTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUserTask.afterCreateUserTaskCounter, 1)

	if mmCreateUserTask.inspectFuncCreateUserTask != nil {
		mmCreateUserTask.inspectFuncCreateUserTask(ctx, userID, taskID)
	}

	mm_params := &RepositoryMockCreateUserTaskParams{ctx, userID, taskID}

	// Record call args
	mmCreateUserTask.CreateUserTaskMock.mutex.Lock()
	mmCreateUserTask.CreateUserTaskMock.callArgs = append(mmCreateUserTask.CreateUserTaskMock.callArgs, mm_params)
	mmCreateUserTask.CreateUserTaskMock.mutex.Unlock()

	for _, e := range mmCreateUserTask.CreateUserTaskMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateUserTask.CreateUserTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUserTask.CreateUserTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUserTask.CreateUserTaskMock.defaultExpectation.params
		mm_got := RepositoryMockCreateUserTaskParams{ctx, userID, taskID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUserTask.t.Errorf("RepositoryMock.CreateUserTask got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUserTask.CreateUserTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUserTask.t.Fatal("No results are set for the RepositoryMock.CreateUserTask")
		}
		return (*mm_results).err
	}
	if mmCreateUserTask.funcCreateUserTask != nil {
		return mmCreateUserTask.funcCreateUserTask(ctx, userID, taskID)
	}
	mmCreateUserTask.t.Fatalf("Unexpected call to RepositoryMock.CreateUserTask. %v %v %v", ctx, userID, taskID)
	return
}

// CreateUserTaskAfterCounter returns a count of finished RepositoryMock.CreateUserTask invocations
func (mmCreateUserTask *RepositoryMock) CreateUserTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUserTask.afterCreateUserTaskCounter)
}

// CreateUserTaskBeforeCounter returns a count of RepositoryMock.CreateUserTask invocations
func (mmCreateUserTask *RepositoryMock) CreateUserTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUserTask.beforeCreateUserTaskCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateUserTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUserTask *mRepositoryMockCreateUserTask) Calls() []*RepositoryMockCreateUserTaskParams {
	mmCreateUserTask.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateUserTaskParams, len(mmCreateUserTask.callArgs))
	copy(argCopy, mmCreateUserTask.callArgs)

	mmCreateUserTask.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserTaskDone returns true if the count of the CreateUserTask invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateUserTaskDone() bool {
	for _, e := range m.CreateUserTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserTaskCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUserTask != nil && mm_atomic.LoadUint64(&m.afterCreateUserTaskCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateUserTaskInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateUserTaskInspect() {
	for _, e := range m.CreateUserTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateUserTask with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserTaskCounter) < 1 {
		if m.CreateUserTaskMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateUserTask")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateUserTask with params: %#v", *m.CreateUserTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUserTask != nil && mm_atomic.LoadUint64(&m.afterCreateUserTaskCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateUserTask")
	}
}

type mRepositoryMockDeleteUserTask struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteUserTaskExpectation
	expectations       []*RepositoryMockDeleteUserTaskExpectation

	callArgs []*RepositoryMockDeleteUserTaskParams
	mutex    sync.RWMutex
}

// RepositoryMockDeleteUserTaskExpectation specifies expectation struct of the Repository.DeleteUserTask
type RepositoryMockDeleteUserTaskExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockDeleteUserTaskParams
	results *RepositoryMockDeleteUserTaskResults
	Counter uint64
}

// RepositoryMockDeleteUserTaskParams contains parameters of the Repository.DeleteUserTask
type RepositoryMockDeleteUserTaskParams struct {
	ctx    context.Context
	userID uint64
	taskID uint64
}

// RepositoryMockDeleteUserTaskResults contains results of the Repository.DeleteUserTask
type RepositoryMockDeleteUserTaskResults struct {
	err error
}

// Expect sets up expected params for Repository.DeleteUserTask
func (mmDeleteUserTask *mRepositoryMockDeleteUserTask) Expect(ctx context.Context, userID uint64, taskID uint64) *mRepositoryMockDeleteUserTask {
	if mmDeleteUserTask.mock.funcDeleteUserTask != nil {
		mmDeleteUserTask.mock.t.Fatalf("RepositoryMock.DeleteUserTask mock is already set by Set")
	}

	if mmDeleteUserTask.defaultExpectation == nil {
		mmDeleteUserTask.defaultExpectation = &RepositoryMockDeleteUserTaskExpectation{}
	}

	mmDeleteUserTask.defaultExpectation.params = &RepositoryMockDeleteUserTaskParams{ctx, userID, taskID}
	for _, e := range mmDeleteUserTask.expectations {
		if minimock.Equal(e.params, mmDeleteUserTask.defaultExpectation.params) {
			mmDeleteUserTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUserTask.defaultExpectation.params)
		}
	}

	return mmDeleteUserTask
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteUserTask
func (mmDeleteUserTask *mRepositoryMockDeleteUserTask) Inspect(f func(ctx context.Context, userID uint64, taskID uint64)) *mRepositoryMockDeleteUserTask {
	if mmDeleteUserTask.mock.inspectFuncDeleteUserTask != nil {
		mmDeleteUserTask.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteUserTask")
	}

	mmDeleteUserTask.mock.inspectFuncDeleteUserTask = f

	return mmDeleteUserTask
}

// Return sets up results that will be returned by Repository.DeleteUserTask
func (mmDeleteUserTask *mRepositoryMockDeleteUserTask) Return(err error) *RepositoryMock {
	if mmDeleteUserTask.mock.funcDeleteUserTask != nil {
		mmDeleteUserTask.mock.t.Fatalf("RepositoryMock.DeleteUserTask mock is already set by Set")
	}

	if mmDeleteUserTask.defaultExpectation == nil {
		mmDeleteUserTask.defaultExpectation = &RepositoryMockDeleteUserTaskExpectation{mock: mmDeleteUserTask.mock}
	}
	mmDeleteUserTask.defaultExpectation.results = &RepositoryMockDeleteUserTaskResults{err}
	return mmDeleteUserTask.mock
}

//Set uses given function f to mock the Repository.DeleteUserTask method
func (mmDeleteUserTask *mRepositoryMockDeleteUserTask) Set(f func(ctx context.Context, userID uint64, taskID uint64) (err error)) *RepositoryMock {
	if mmDeleteUserTask.defaultExpectation != nil {
		mmDeleteUserTask.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteUserTask method")
	}

	if len(mmDeleteUserTask.expectations) > 0 {
		mmDeleteUserTask.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteUserTask method")
	}

	mmDeleteUserTask.mock.funcDeleteUserTask = f
	return mmDeleteUserTask.mock
}

// When sets expectation for the Repository.DeleteUserTask which will trigger the result defined by the following
// Then helper
func (mmDeleteUserTask *mRepositoryMockDeleteUserTask) When(ctx context.Context, userID uint64, taskID uint64) *RepositoryMockDeleteUserTaskExpectation {
	if mmDeleteUserTask.mock.funcDeleteUserTask != nil {
		mmDeleteUserTask.mock.t.Fatalf("RepositoryMock.DeleteUserTask mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteUserTaskExpectation{
		mock:   mmDeleteUserTask.mock,
		params: &RepositoryMockDeleteUserTaskParams{ctx, userID, taskID},
	}
	mmDeleteUserTask.expectations = append(mmDeleteUserTask.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteUserTask return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteUserTaskExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteUserTaskResults{err}
	return e.mock
}

// DeleteUserTask implements Repository
func (mmDeleteUserTask *RepositoryMock) DeleteUserTask(ctx context.Context, userID uint64, taskID uint64) (err error) {
	mm_atomic.AddUint64(&mmDeleteUserTask.beforeDeleteUserTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUserTask.afterDeleteUserTaskCounter, 1)

	if mmDeleteUserTask.inspectFuncDeleteUserTask != nil {
		mmDeleteUserTask.inspectFuncDeleteUserTask(ctx, userID, taskID)
	}

	mm_params := &RepositoryMockDeleteUserTaskParams{ctx, userID, taskID}

	// Record call args
	mmDeleteUserTask.DeleteUserTaskMock.mutex.Lock()
	mmDeleteUserTask.DeleteUserTaskMock.callArgs = append(mmDeleteUserTask.DeleteUserTaskMock.callArgs, mm_params)
	mmDeleteUserTask.DeleteUserTaskMock.mutex.Unlock()

	for _, e := range mmDeleteUserTask.DeleteUserTaskMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUserTask.DeleteUserTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUserTask.DeleteUserTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUserTask.DeleteUserTaskMock.defaultExpectation.params
		mm_got := RepositoryMockDeleteUserTaskParams{ctx, userID, taskID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUserTask.t.Errorf("RepositoryMock.DeleteUserTask got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUserTask.DeleteUserTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUserTask.t.Fatal("No results are set for the RepositoryMock.DeleteUserTask")
		}
		return (*mm_results).err
	}
	if mmDeleteUserTask.funcDeleteUserTask != nil {
		return mmDeleteUserTask.funcDeleteUserTask(ctx, userID, taskID)
	}
	mmDeleteUserTask.t.Fatalf("Unexpected call to RepositoryMock.DeleteUserTask. %v %v %v", ctx, userID, taskID)
	return
}

// DeleteUserTaskAfterCounter returns a count of finished RepositoryMock.DeleteUserTask invocations
func (mmDeleteUserTask *RepositoryMock) DeleteUserTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUserTask.afterDeleteUserTaskCounter)
}

// DeleteUserTaskBeforeCounter returns a count of RepositoryMock.DeleteUserTask invocations
func (mmDeleteUserTask *RepositoryMock) DeleteUserTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUserTask.beforeDeleteUserTaskCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteUserTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUserTask *mRepositoryMockDeleteUserTask) Calls() []*RepositoryMockDeleteUserTaskParams {
	mmDeleteUserTask.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteUserTaskParams, len(mmDeleteUserTask.callArgs))
	copy(argCopy, mmDeleteUserTask.callArgs)

	mmDeleteUserTask.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserTaskDone returns true if the count of the DeleteUserTask invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteUserTaskDone() bool {
	for _, e := range m.DeleteUserTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteUserTaskCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUserTask != nil && mm_atomic.LoadUint64(&m.afterDeleteUserTaskCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteUserTaskInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteUserTaskInspect() {
	for _, e := range m.DeleteUserTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteUserTask with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteUserTaskCounter) < 1 {
		if m.DeleteUserTaskMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteUserTask")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteUserTask with params: %#v", *m.DeleteUserTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUserTask != nil && mm_atomic.LoadUint64(&m.afterDeleteUserTaskCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteUserTask")
	}
}

type mRepositoryMockGetAllTasks struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetAllTasksExpectation
	expectations       []*RepositoryMockGetAllTasksExpectation

	callArgs []*RepositoryMockGetAllTasksParams
	mutex    sync.RWMutex
}

// RepositoryMockGetAllTasksExpectation specifies expectation struct of the Repository.GetAllTasks
type RepositoryMockGetAllTasksExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetAllTasksParams
	results *RepositoryMockGetAllTasksResults
	Counter uint64
}

// RepositoryMockGetAllTasksParams contains parameters of the Repository.GetAllTasks
type RepositoryMockGetAllTasksParams struct {
	ctx context.Context
}

// RepositoryMockGetAllTasksResults contains results of the Repository.GetAllTasks
type RepositoryMockGetAllTasksResults struct {
	tpa1 []*models.Task
	err  error
}

// Expect sets up expected params for Repository.GetAllTasks
func (mmGetAllTasks *mRepositoryMockGetAllTasks) Expect(ctx context.Context) *mRepositoryMockGetAllTasks {
	if mmGetAllTasks.mock.funcGetAllTasks != nil {
		mmGetAllTasks.mock.t.Fatalf("RepositoryMock.GetAllTasks mock is already set by Set")
	}

	if mmGetAllTasks.defaultExpectation == nil {
		mmGetAllTasks.defaultExpectation = &RepositoryMockGetAllTasksExpectation{}
	}

	mmGetAllTasks.defaultExpectation.params = &RepositoryMockGetAllTasksParams{ctx}
	for _, e := range mmGetAllTasks.expectations {
		if minimock.Equal(e.params, mmGetAllTasks.defaultExpectation.params) {
			mmGetAllTasks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllTasks.defaultExpectation.params)
		}
	}

	return mmGetAllTasks
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetAllTasks
func (mmGetAllTasks *mRepositoryMockGetAllTasks) Inspect(f func(ctx context.Context)) *mRepositoryMockGetAllTasks {
	if mmGetAllTasks.mock.inspectFuncGetAllTasks != nil {
		mmGetAllTasks.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetAllTasks")
	}

	mmGetAllTasks.mock.inspectFuncGetAllTasks = f

	return mmGetAllTasks
}

// Return sets up results that will be returned by Repository.GetAllTasks
func (mmGetAllTasks *mRepositoryMockGetAllTasks) Return(tpa1 []*models.Task, err error) *RepositoryMock {
	if mmGetAllTasks.mock.funcGetAllTasks != nil {
		mmGetAllTasks.mock.t.Fatalf("RepositoryMock.GetAllTasks mock is already set by Set")
	}

	if mmGetAllTasks.defaultExpectation == nil {
		mmGetAllTasks.defaultExpectation = &RepositoryMockGetAllTasksExpectation{mock: mmGetAllTasks.mock}
	}
	mmGetAllTasks.defaultExpectation.results = &RepositoryMockGetAllTasksResults{tpa1, err}
	return mmGetAllTasks.mock
}

//Set uses given function f to mock the Repository.GetAllTasks method
func (mmGetAllTasks *mRepositoryMockGetAllTasks) Set(f func(ctx context.Context) (tpa1 []*models.Task, err error)) *RepositoryMock {
	if mmGetAllTasks.defaultExpectation != nil {
		mmGetAllTasks.mock.t.Fatalf("Default expectation is already set for the Repository.GetAllTasks method")
	}

	if len(mmGetAllTasks.expectations) > 0 {
		mmGetAllTasks.mock.t.Fatalf("Some expectations are already set for the Repository.GetAllTasks method")
	}

	mmGetAllTasks.mock.funcGetAllTasks = f
	return mmGetAllTasks.mock
}

// When sets expectation for the Repository.GetAllTasks which will trigger the result defined by the following
// Then helper
func (mmGetAllTasks *mRepositoryMockGetAllTasks) When(ctx context.Context) *RepositoryMockGetAllTasksExpectation {
	if mmGetAllTasks.mock.funcGetAllTasks != nil {
		mmGetAllTasks.mock.t.Fatalf("RepositoryMock.GetAllTasks mock is already set by Set")
	}

	expectation := &RepositoryMockGetAllTasksExpectation{
		mock:   mmGetAllTasks.mock,
		params: &RepositoryMockGetAllTasksParams{ctx},
	}
	mmGetAllTasks.expectations = append(mmGetAllTasks.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetAllTasks return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetAllTasksExpectation) Then(tpa1 []*models.Task, err error) *RepositoryMock {
	e.results = &RepositoryMockGetAllTasksResults{tpa1, err}
	return e.mock
}

// GetAllTasks implements Repository
func (mmGetAllTasks *RepositoryMock) GetAllTasks(ctx context.Context) (tpa1 []*models.Task, err error) {
	mm_atomic.AddUint64(&mmGetAllTasks.beforeGetAllTasksCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllTasks.afterGetAllTasksCounter, 1)

	if mmGetAllTasks.inspectFuncGetAllTasks != nil {
		mmGetAllTasks.inspectFuncGetAllTasks(ctx)
	}

	mm_params := &RepositoryMockGetAllTasksParams{ctx}

	// Record call args
	mmGetAllTasks.GetAllTasksMock.mutex.Lock()
	mmGetAllTasks.GetAllTasksMock.callArgs = append(mmGetAllTasks.GetAllTasksMock.callArgs, mm_params)
	mmGetAllTasks.GetAllTasksMock.mutex.Unlock()

	for _, e := range mmGetAllTasks.GetAllTasksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tpa1, e.results.err
		}
	}

	if mmGetAllTasks.GetAllTasksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllTasks.GetAllTasksMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllTasks.GetAllTasksMock.defaultExpectation.params
		mm_got := RepositoryMockGetAllTasksParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllTasks.t.Errorf("RepositoryMock.GetAllTasks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllTasks.GetAllTasksMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllTasks.t.Fatal("No results are set for the RepositoryMock.GetAllTasks")
		}
		return (*mm_results).tpa1, (*mm_results).err
	}
	if mmGetAllTasks.funcGetAllTasks != nil {
		return mmGetAllTasks.funcGetAllTasks(ctx)
	}
	mmGetAllTasks.t.Fatalf("Unexpected call to RepositoryMock.GetAllTasks. %v", ctx)
	return
}

// GetAllTasksAfterCounter returns a count of finished RepositoryMock.GetAllTasks invocations
func (mmGetAllTasks *RepositoryMock) GetAllTasksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllTasks.afterGetAllTasksCounter)
}

// GetAllTasksBeforeCounter returns a count of RepositoryMock.GetAllTasks invocations
func (mmGetAllTasks *RepositoryMock) GetAllTasksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllTasks.beforeGetAllTasksCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetAllTasks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllTasks *mRepositoryMockGetAllTasks) Calls() []*RepositoryMockGetAllTasksParams {
	mmGetAllTasks.mutex.RLock()

	argCopy := make([]*RepositoryMockGetAllTasksParams, len(mmGetAllTasks.callArgs))
	copy(argCopy, mmGetAllTasks.callArgs)

	mmGetAllTasks.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllTasksDone returns true if the count of the GetAllTasks invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetAllTasksDone() bool {
	for _, e := range m.GetAllTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllTasksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllTasksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllTasks != nil && mm_atomic.LoadUint64(&m.afterGetAllTasksCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAllTasksInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetAllTasksInspect() {
	for _, e := range m.GetAllTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetAllTasks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllTasksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllTasksCounter) < 1 {
		if m.GetAllTasksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetAllTasks")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetAllTasks with params: %#v", *m.GetAllTasksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllTasks != nil && mm_atomic.LoadUint64(&m.afterGetAllTasksCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetAllTasks")
	}
}

type mRepositoryMockGetTask struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetTaskExpectation
	expectations       []*RepositoryMockGetTaskExpectation

	callArgs []*RepositoryMockGetTaskParams
	mutex    sync.RWMutex
}

// RepositoryMockGetTaskExpectation specifies expectation struct of the Repository.GetTask
type RepositoryMockGetTaskExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetTaskParams
	results *RepositoryMockGetTaskResults
	Counter uint64
}

// RepositoryMockGetTaskParams contains parameters of the Repository.GetTask
type RepositoryMockGetTaskParams struct {
	ctx context.Context
	ID  uint64
}

// RepositoryMockGetTaskResults contains results of the Repository.GetTask
type RepositoryMockGetTaskResults struct {
	tp1 *models.Task
	err error
}

// Expect sets up expected params for Repository.GetTask
func (mmGetTask *mRepositoryMockGetTask) Expect(ctx context.Context, ID uint64) *mRepositoryMockGetTask {
	if mmGetTask.mock.funcGetTask != nil {
		mmGetTask.mock.t.Fatalf("RepositoryMock.GetTask mock is already set by Set")
	}

	if mmGetTask.defaultExpectation == nil {
		mmGetTask.defaultExpectation = &RepositoryMockGetTaskExpectation{}
	}

	mmGetTask.defaultExpectation.params = &RepositoryMockGetTaskParams{ctx, ID}
	for _, e := range mmGetTask.expectations {
		if minimock.Equal(e.params, mmGetTask.defaultExpectation.params) {
			mmGetTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTask.defaultExpectation.params)
		}
	}

	return mmGetTask
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetTask
func (mmGetTask *mRepositoryMockGetTask) Inspect(f func(ctx context.Context, ID uint64)) *mRepositoryMockGetTask {
	if mmGetTask.mock.inspectFuncGetTask != nil {
		mmGetTask.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetTask")
	}

	mmGetTask.mock.inspectFuncGetTask = f

	return mmGetTask
}

// Return sets up results that will be returned by Repository.GetTask
func (mmGetTask *mRepositoryMockGetTask) Return(tp1 *models.Task, err error) *RepositoryMock {
	if mmGetTask.mock.funcGetTask != nil {
		mmGetTask.mock.t.Fatalf("RepositoryMock.GetTask mock is already set by Set")
	}

	if mmGetTask.defaultExpectation == nil {
		mmGetTask.defaultExpectation = &RepositoryMockGetTaskExpectation{mock: mmGetTask.mock}
	}
	mmGetTask.defaultExpectation.results = &RepositoryMockGetTaskResults{tp1, err}
	return mmGetTask.mock
}

//Set uses given function f to mock the Repository.GetTask method
func (mmGetTask *mRepositoryMockGetTask) Set(f func(ctx context.Context, ID uint64) (tp1 *models.Task, err error)) *RepositoryMock {
	if mmGetTask.defaultExpectation != nil {
		mmGetTask.mock.t.Fatalf("Default expectation is already set for the Repository.GetTask method")
	}

	if len(mmGetTask.expectations) > 0 {
		mmGetTask.mock.t.Fatalf("Some expectations are already set for the Repository.GetTask method")
	}

	mmGetTask.mock.funcGetTask = f
	return mmGetTask.mock
}

// When sets expectation for the Repository.GetTask which will trigger the result defined by the following
// Then helper
func (mmGetTask *mRepositoryMockGetTask) When(ctx context.Context, ID uint64) *RepositoryMockGetTaskExpectation {
	if mmGetTask.mock.funcGetTask != nil {
		mmGetTask.mock.t.Fatalf("RepositoryMock.GetTask mock is already set by Set")
	}

	expectation := &RepositoryMockGetTaskExpectation{
		mock:   mmGetTask.mock,
		params: &RepositoryMockGetTaskParams{ctx, ID},
	}
	mmGetTask.expectations = append(mmGetTask.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetTask return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetTaskExpectation) Then(tp1 *models.Task, err error) *RepositoryMock {
	e.results = &RepositoryMockGetTaskResults{tp1, err}
	return e.mock
}

// GetTask implements Repository
func (mmGetTask *RepositoryMock) GetTask(ctx context.Context, ID uint64) (tp1 *models.Task, err error) {
	mm_atomic.AddUint64(&mmGetTask.beforeGetTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTask.afterGetTaskCounter, 1)

	if mmGetTask.inspectFuncGetTask != nil {
		mmGetTask.inspectFuncGetTask(ctx, ID)
	}

	mm_params := &RepositoryMockGetTaskParams{ctx, ID}

	// Record call args
	mmGetTask.GetTaskMock.mutex.Lock()
	mmGetTask.GetTaskMock.callArgs = append(mmGetTask.GetTaskMock.callArgs, mm_params)
	mmGetTask.GetTaskMock.mutex.Unlock()

	for _, e := range mmGetTask.GetTaskMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmGetTask.GetTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTask.GetTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTask.GetTaskMock.defaultExpectation.params
		mm_got := RepositoryMockGetTaskParams{ctx, ID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTask.t.Errorf("RepositoryMock.GetTask got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTask.GetTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTask.t.Fatal("No results are set for the RepositoryMock.GetTask")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmGetTask.funcGetTask != nil {
		return mmGetTask.funcGetTask(ctx, ID)
	}
	mmGetTask.t.Fatalf("Unexpected call to RepositoryMock.GetTask. %v %v", ctx, ID)
	return
}

// GetTaskAfterCounter returns a count of finished RepositoryMock.GetTask invocations
func (mmGetTask *RepositoryMock) GetTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTask.afterGetTaskCounter)
}

// GetTaskBeforeCounter returns a count of RepositoryMock.GetTask invocations
func (mmGetTask *RepositoryMock) GetTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTask.beforeGetTaskCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTask *mRepositoryMockGetTask) Calls() []*RepositoryMockGetTaskParams {
	mmGetTask.mutex.RLock()

	argCopy := make([]*RepositoryMockGetTaskParams, len(mmGetTask.callArgs))
	copy(argCopy, mmGetTask.callArgs)

	mmGetTask.mutex.RUnlock()

	return argCopy
}

// MinimockGetTaskDone returns true if the count of the GetTask invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetTaskDone() bool {
	for _, e := range m.GetTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTaskCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTask != nil && mm_atomic.LoadUint64(&m.afterGetTaskCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetTaskInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetTaskInspect() {
	for _, e := range m.GetTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetTask with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTaskCounter) < 1 {
		if m.GetTaskMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetTask")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetTask with params: %#v", *m.GetTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTask != nil && mm_atomic.LoadUint64(&m.afterGetTaskCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetTask")
	}
}

type mRepositoryMockGetUserTask struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetUserTaskExpectation
	expectations       []*RepositoryMockGetUserTaskExpectation

	callArgs []*RepositoryMockGetUserTaskParams
	mutex    sync.RWMutex
}

// RepositoryMockGetUserTaskExpectation specifies expectation struct of the Repository.GetUserTask
type RepositoryMockGetUserTaskExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetUserTaskParams
	results *RepositoryMockGetUserTaskResults
	Counter uint64
}

// RepositoryMockGetUserTaskParams contains parameters of the Repository.GetUserTask
type RepositoryMockGetUserTaskParams struct {
	ctx    context.Context
	userID uint64
	taskID uint64
}

// RepositoryMockGetUserTaskResults contains results of the Repository.GetUserTask
type RepositoryMockGetUserTaskResults struct {
	up1 *models.UserTask
	err error
}

// Expect sets up expected params for Repository.GetUserTask
func (mmGetUserTask *mRepositoryMockGetUserTask) Expect(ctx context.Context, userID uint64, taskID uint64) *mRepositoryMockGetUserTask {
	if mmGetUserTask.mock.funcGetUserTask != nil {
		mmGetUserTask.mock.t.Fatalf("RepositoryMock.GetUserTask mock is already set by Set")
	}

	if mmGetUserTask.defaultExpectation == nil {
		mmGetUserTask.defaultExpectation = &RepositoryMockGetUserTaskExpectation{}
	}

	mmGetUserTask.defaultExpectation.params = &RepositoryMockGetUserTaskParams{ctx, userID, taskID}
	for _, e := range mmGetUserTask.expectations {
		if minimock.Equal(e.params, mmGetUserTask.defaultExpectation.params) {
			mmGetUserTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserTask.defaultExpectation.params)
		}
	}

	return mmGetUserTask
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetUserTask
func (mmGetUserTask *mRepositoryMockGetUserTask) Inspect(f func(ctx context.Context, userID uint64, taskID uint64)) *mRepositoryMockGetUserTask {
	if mmGetUserTask.mock.inspectFuncGetUserTask != nil {
		mmGetUserTask.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetUserTask")
	}

	mmGetUserTask.mock.inspectFuncGetUserTask = f

	return mmGetUserTask
}

// Return sets up results that will be returned by Repository.GetUserTask
func (mmGetUserTask *mRepositoryMockGetUserTask) Return(up1 *models.UserTask, err error) *RepositoryMock {
	if mmGetUserTask.mock.funcGetUserTask != nil {
		mmGetUserTask.mock.t.Fatalf("RepositoryMock.GetUserTask mock is already set by Set")
	}

	if mmGetUserTask.defaultExpectation == nil {
		mmGetUserTask.defaultExpectation = &RepositoryMockGetUserTaskExpectation{mock: mmGetUserTask.mock}
	}
	mmGetUserTask.defaultExpectation.results = &RepositoryMockGetUserTaskResults{up1, err}
	return mmGetUserTask.mock
}

//Set uses given function f to mock the Repository.GetUserTask method
func (mmGetUserTask *mRepositoryMockGetUserTask) Set(f func(ctx context.Context, userID uint64, taskID uint64) (up1 *models.UserTask, err error)) *RepositoryMock {
	if mmGetUserTask.defaultExpectation != nil {
		mmGetUserTask.mock.t.Fatalf("Default expectation is already set for the Repository.GetUserTask method")
	}

	if len(mmGetUserTask.expectations) > 0 {
		mmGetUserTask.mock.t.Fatalf("Some expectations are already set for the Repository.GetUserTask method")
	}

	mmGetUserTask.mock.funcGetUserTask = f
	return mmGetUserTask.mock
}

// When sets expectation for the Repository.GetUserTask which will trigger the result defined by the following
// Then helper
func (mmGetUserTask *mRepositoryMockGetUserTask) When(ctx context.Context, userID uint64, taskID uint64) *RepositoryMockGetUserTaskExpectation {
	if mmGetUserTask.mock.funcGetUserTask != nil {
		mmGetUserTask.mock.t.Fatalf("RepositoryMock.GetUserTask mock is already set by Set")
	}

	expectation := &RepositoryMockGetUserTaskExpectation{
		mock:   mmGetUserTask.mock,
		params: &RepositoryMockGetUserTaskParams{ctx, userID, taskID},
	}
	mmGetUserTask.expectations = append(mmGetUserTask.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetUserTask return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetUserTaskExpectation) Then(up1 *models.UserTask, err error) *RepositoryMock {
	e.results = &RepositoryMockGetUserTaskResults{up1, err}
	return e.mock
}

// GetUserTask implements Repository
func (mmGetUserTask *RepositoryMock) GetUserTask(ctx context.Context, userID uint64, taskID uint64) (up1 *models.UserTask, err error) {
	mm_atomic.AddUint64(&mmGetUserTask.beforeGetUserTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserTask.afterGetUserTaskCounter, 1)

	if mmGetUserTask.inspectFuncGetUserTask != nil {
		mmGetUserTask.inspectFuncGetUserTask(ctx, userID, taskID)
	}

	mm_params := &RepositoryMockGetUserTaskParams{ctx, userID, taskID}

	// Record call args
	mmGetUserTask.GetUserTaskMock.mutex.Lock()
	mmGetUserTask.GetUserTaskMock.callArgs = append(mmGetUserTask.GetUserTaskMock.callArgs, mm_params)
	mmGetUserTask.GetUserTaskMock.mutex.Unlock()

	for _, e := range mmGetUserTask.GetUserTaskMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserTask.GetUserTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserTask.GetUserTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserTask.GetUserTaskMock.defaultExpectation.params
		mm_got := RepositoryMockGetUserTaskParams{ctx, userID, taskID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserTask.t.Errorf("RepositoryMock.GetUserTask got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserTask.GetUserTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserTask.t.Fatal("No results are set for the RepositoryMock.GetUserTask")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserTask.funcGetUserTask != nil {
		return mmGetUserTask.funcGetUserTask(ctx, userID, taskID)
	}
	mmGetUserTask.t.Fatalf("Unexpected call to RepositoryMock.GetUserTask. %v %v %v", ctx, userID, taskID)
	return
}

// GetUserTaskAfterCounter returns a count of finished RepositoryMock.GetUserTask invocations
func (mmGetUserTask *RepositoryMock) GetUserTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserTask.afterGetUserTaskCounter)
}

// GetUserTaskBeforeCounter returns a count of RepositoryMock.GetUserTask invocations
func (mmGetUserTask *RepositoryMock) GetUserTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserTask.beforeGetUserTaskCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetUserTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserTask *mRepositoryMockGetUserTask) Calls() []*RepositoryMockGetUserTaskParams {
	mmGetUserTask.mutex.RLock()

	argCopy := make([]*RepositoryMockGetUserTaskParams, len(mmGetUserTask.callArgs))
	copy(argCopy, mmGetUserTask.callArgs)

	mmGetUserTask.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserTaskDone returns true if the count of the GetUserTask invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetUserTaskDone() bool {
	for _, e := range m.GetUserTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserTaskCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserTask != nil && mm_atomic.LoadUint64(&m.afterGetUserTaskCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserTaskInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetUserTaskInspect() {
	for _, e := range m.GetUserTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetUserTask with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserTaskCounter) < 1 {
		if m.GetUserTaskMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetUserTask")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetUserTask with params: %#v", *m.GetUserTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserTask != nil && mm_atomic.LoadUint64(&m.afterGetUserTaskCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetUserTask")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateTaskInspect()

		m.MinimockCreateTaskStageInspect()

		m.MinimockCreateUserInspect()

		m.MinimockCreateUserTaskInspect()

		m.MinimockDeleteUserTaskInspect()

		m.MinimockGetAllTasksInspect()

		m.MinimockGetTaskInspect()

		m.MinimockGetUserTaskInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateTaskDone() &&
		m.MinimockCreateTaskStageDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockCreateUserTaskDone() &&
		m.MinimockDeleteUserTaskDone() &&
		m.MinimockGetAllTasksDone() &&
		m.MinimockGetTaskDone() &&
		m.MinimockGetUserTaskDone()
}
