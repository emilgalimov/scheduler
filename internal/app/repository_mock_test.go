package app

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/emilgalimov/homework-2/internal/app.Repository -o ./internal/app/repository_mock_test.go -n RepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/emilgalimov/homework-2/internal/models"
)

// RepositoryMock implements Repository
type RepositoryMock struct {
	t minimock.Tester

	funcCreateTask          func(ctx context.Context, t1 models.Task) (u1 uint64, err error)
	inspectFuncCreateTask   func(ctx context.Context, t1 models.Task)
	afterCreateTaskCounter  uint64
	beforeCreateTaskCounter uint64
	CreateTaskMock          mRepositoryMockCreateTask

	funcCreateUser          func(ctx context.Context) (u1 uint64, err error)
	inspectFuncCreateUser   func(ctx context.Context)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mRepositoryMockCreateUser
}

// NewRepositoryMock returns a mock for Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateTaskMock = mRepositoryMockCreateTask{mock: m}
	m.CreateTaskMock.callArgs = []*RepositoryMockCreateTaskParams{}

	m.CreateUserMock = mRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*RepositoryMockCreateUserParams{}

	return m
}

type mRepositoryMockCreateTask struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateTaskExpectation
	expectations       []*RepositoryMockCreateTaskExpectation

	callArgs []*RepositoryMockCreateTaskParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateTaskExpectation specifies expectation struct of the Repository.CreateTask
type RepositoryMockCreateTaskExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateTaskParams
	results *RepositoryMockCreateTaskResults
	Counter uint64
}

// RepositoryMockCreateTaskParams contains parameters of the Repository.CreateTask
type RepositoryMockCreateTaskParams struct {
	ctx context.Context
	t1  models.Task
}

// RepositoryMockCreateTaskResults contains results of the Repository.CreateTask
type RepositoryMockCreateTaskResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for Repository.CreateTask
func (mmCreateTask *mRepositoryMockCreateTask) Expect(ctx context.Context, t1 models.Task) *mRepositoryMockCreateTask {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("RepositoryMock.CreateTask mock is already set by Set")
	}

	if mmCreateTask.defaultExpectation == nil {
		mmCreateTask.defaultExpectation = &RepositoryMockCreateTaskExpectation{}
	}

	mmCreateTask.defaultExpectation.params = &RepositoryMockCreateTaskParams{ctx, t1}
	for _, e := range mmCreateTask.expectations {
		if minimock.Equal(e.params, mmCreateTask.defaultExpectation.params) {
			mmCreateTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTask.defaultExpectation.params)
		}
	}

	return mmCreateTask
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateTask
func (mmCreateTask *mRepositoryMockCreateTask) Inspect(f func(ctx context.Context, t1 models.Task)) *mRepositoryMockCreateTask {
	if mmCreateTask.mock.inspectFuncCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateTask")
	}

	mmCreateTask.mock.inspectFuncCreateTask = f

	return mmCreateTask
}

// Return sets up results that will be returned by Repository.CreateTask
func (mmCreateTask *mRepositoryMockCreateTask) Return(u1 uint64, err error) *RepositoryMock {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("RepositoryMock.CreateTask mock is already set by Set")
	}

	if mmCreateTask.defaultExpectation == nil {
		mmCreateTask.defaultExpectation = &RepositoryMockCreateTaskExpectation{mock: mmCreateTask.mock}
	}
	mmCreateTask.defaultExpectation.results = &RepositoryMockCreateTaskResults{u1, err}
	return mmCreateTask.mock
}

//Set uses given function f to mock the Repository.CreateTask method
func (mmCreateTask *mRepositoryMockCreateTask) Set(f func(ctx context.Context, t1 models.Task) (u1 uint64, err error)) *RepositoryMock {
	if mmCreateTask.defaultExpectation != nil {
		mmCreateTask.mock.t.Fatalf("Default expectation is already set for the Repository.CreateTask method")
	}

	if len(mmCreateTask.expectations) > 0 {
		mmCreateTask.mock.t.Fatalf("Some expectations are already set for the Repository.CreateTask method")
	}

	mmCreateTask.mock.funcCreateTask = f
	return mmCreateTask.mock
}

// When sets expectation for the Repository.CreateTask which will trigger the result defined by the following
// Then helper
func (mmCreateTask *mRepositoryMockCreateTask) When(ctx context.Context, t1 models.Task) *RepositoryMockCreateTaskExpectation {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("RepositoryMock.CreateTask mock is already set by Set")
	}

	expectation := &RepositoryMockCreateTaskExpectation{
		mock:   mmCreateTask.mock,
		params: &RepositoryMockCreateTaskParams{ctx, t1},
	}
	mmCreateTask.expectations = append(mmCreateTask.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateTask return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateTaskExpectation) Then(u1 uint64, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateTaskResults{u1, err}
	return e.mock
}

// CreateTask implements Repository
func (mmCreateTask *RepositoryMock) CreateTask(ctx context.Context, t1 models.Task) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmCreateTask.beforeCreateTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTask.afterCreateTaskCounter, 1)

	if mmCreateTask.inspectFuncCreateTask != nil {
		mmCreateTask.inspectFuncCreateTask(ctx, t1)
	}

	mm_params := &RepositoryMockCreateTaskParams{ctx, t1}

	// Record call args
	mmCreateTask.CreateTaskMock.mutex.Lock()
	mmCreateTask.CreateTaskMock.callArgs = append(mmCreateTask.CreateTaskMock.callArgs, mm_params)
	mmCreateTask.CreateTaskMock.mutex.Unlock()

	for _, e := range mmCreateTask.CreateTaskMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreateTask.CreateTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTask.CreateTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTask.CreateTaskMock.defaultExpectation.params
		mm_got := RepositoryMockCreateTaskParams{ctx, t1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTask.t.Errorf("RepositoryMock.CreateTask got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTask.CreateTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTask.t.Fatal("No results are set for the RepositoryMock.CreateTask")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreateTask.funcCreateTask != nil {
		return mmCreateTask.funcCreateTask(ctx, t1)
	}
	mmCreateTask.t.Fatalf("Unexpected call to RepositoryMock.CreateTask. %v %v", ctx, t1)
	return
}

// CreateTaskAfterCounter returns a count of finished RepositoryMock.CreateTask invocations
func (mmCreateTask *RepositoryMock) CreateTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTask.afterCreateTaskCounter)
}

// CreateTaskBeforeCounter returns a count of RepositoryMock.CreateTask invocations
func (mmCreateTask *RepositoryMock) CreateTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTask.beforeCreateTaskCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTask *mRepositoryMockCreateTask) Calls() []*RepositoryMockCreateTaskParams {
	mmCreateTask.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateTaskParams, len(mmCreateTask.callArgs))
	copy(argCopy, mmCreateTask.callArgs)

	mmCreateTask.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTaskDone returns true if the count of the CreateTask invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateTaskDone() bool {
	for _, e := range m.CreateTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateTaskCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTask != nil && mm_atomic.LoadUint64(&m.afterCreateTaskCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateTaskInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateTaskInspect() {
	for _, e := range m.CreateTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateTask with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateTaskCounter) < 1 {
		if m.CreateTaskMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateTask")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateTask with params: %#v", *m.CreateTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTask != nil && mm_atomic.LoadUint64(&m.afterCreateTaskCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateTask")
	}
}

type mRepositoryMockCreateUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateUserExpectation
	expectations       []*RepositoryMockCreateUserExpectation

	callArgs []*RepositoryMockCreateUserParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateUserExpectation specifies expectation struct of the Repository.CreateUser
type RepositoryMockCreateUserExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateUserParams
	results *RepositoryMockCreateUserResults
	Counter uint64
}

// RepositoryMockCreateUserParams contains parameters of the Repository.CreateUser
type RepositoryMockCreateUserParams struct {
	ctx context.Context
}

// RepositoryMockCreateUserResults contains results of the Repository.CreateUser
type RepositoryMockCreateUserResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Expect(ctx context.Context) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{}
	}

	mmCreateUser.defaultExpectation.params = &RepositoryMockCreateUserParams{ctx}
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Inspect(f func(ctx context.Context)) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Return(u1 uint64, err error) *RepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &RepositoryMockCreateUserResults{u1, err}
	return mmCreateUser.mock
}

//Set uses given function f to mock the Repository.CreateUser method
func (mmCreateUser *mRepositoryMockCreateUser) Set(f func(ctx context.Context) (u1 uint64, err error)) *RepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the Repository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the Repository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	return mmCreateUser.mock
}

// When sets expectation for the Repository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mRepositoryMockCreateUser) When(ctx context.Context) *RepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &RepositoryMockCreateUserExpectation{
		mock:   mmCreateUser.mock,
		params: &RepositoryMockCreateUserParams{ctx},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateUserExpectation) Then(u1 uint64, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateUserResults{u1, err}
	return e.mock
}

// CreateUser implements Repository
func (mmCreateUser *RepositoryMock) CreateUser(ctx context.Context) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx)
	}

	mm_params := &RepositoryMockCreateUserParams{ctx}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_got := RepositoryMockCreateUserParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("RepositoryMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the RepositoryMock.CreateUser")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx)
	}
	mmCreateUser.t.Fatalf("Unexpected call to RepositoryMock.CreateUser. %v", ctx)
	return
}

// CreateUserAfterCounter returns a count of finished RepositoryMock.CreateUser invocations
func (mmCreateUser *RepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of RepositoryMock.CreateUser invocations
func (mmCreateUser *RepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mRepositoryMockCreateUser) Calls() []*RepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateUserDone() bool {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateUser")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateTaskInspect()

		m.MinimockCreateUserInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateTaskDone() &&
		m.MinimockCreateUserDone()
}
