package app

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/emilgalimov/homework-2/internal/app.Repository -o ./internal/app/repository_mock_test.go -n RepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/emilgalimov/homework-2/internal/models"
)

// RepositoryMock implements Repository
type RepositoryMock struct {
	t minimock.Tester

	funcCreateTask          func(ctx context.Context, t1 models.Task) (u1 uint64, err error)
	inspectFuncCreateTask   func(ctx context.Context, t1 models.Task)
	afterCreateTaskCounter  uint64
	beforeCreateTaskCounter uint64
	CreateTaskMock          mRepositoryMockCreateTask

	funcCreateTaskStage          func(ctx context.Context, taskStage models.TaskStage, taskID uint64) (u1 uint64, err error)
	inspectFuncCreateTaskStage   func(ctx context.Context, taskStage models.TaskStage, taskID uint64)
	afterCreateTaskStageCounter  uint64
	beforeCreateTaskStageCounter uint64
	CreateTaskStageMock          mRepositoryMockCreateTaskStage

	funcCreateUser          func(ctx context.Context) (u1 uint64, err error)
	inspectFuncCreateUser   func(ctx context.Context)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mRepositoryMockCreateUser

	funcGetAllTasks          func(ctx context.Context) (tpa1 []*models.Task, err error)
	inspectFuncGetAllTasks   func(ctx context.Context)
	afterGetAllTasksCounter  uint64
	beforeGetAllTasksCounter uint64
	GetAllTasksMock          mRepositoryMockGetAllTasks

	funcGetTask          func(ctx context.Context, ID uint64) (tp1 *models.Task, err error)
	inspectFuncGetTask   func(ctx context.Context, ID uint64)
	afterGetTaskCounter  uint64
	beforeGetTaskCounter uint64
	GetTaskMock          mRepositoryMockGetTask
}

// NewRepositoryMock returns a mock for Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateTaskMock = mRepositoryMockCreateTask{mock: m}
	m.CreateTaskMock.callArgs = []*RepositoryMockCreateTaskParams{}

	m.CreateTaskStageMock = mRepositoryMockCreateTaskStage{mock: m}
	m.CreateTaskStageMock.callArgs = []*RepositoryMockCreateTaskStageParams{}

	m.CreateUserMock = mRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*RepositoryMockCreateUserParams{}

	m.GetAllTasksMock = mRepositoryMockGetAllTasks{mock: m}
	m.GetAllTasksMock.callArgs = []*RepositoryMockGetAllTasksParams{}

	m.GetTaskMock = mRepositoryMockGetTask{mock: m}
	m.GetTaskMock.callArgs = []*RepositoryMockGetTaskParams{}

	return m
}

type mRepositoryMockCreateTask struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateTaskExpectation
	expectations       []*RepositoryMockCreateTaskExpectation

	callArgs []*RepositoryMockCreateTaskParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateTaskExpectation specifies expectation struct of the Repository.CreateTask
type RepositoryMockCreateTaskExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateTaskParams
	results *RepositoryMockCreateTaskResults
	Counter uint64
}

// RepositoryMockCreateTaskParams contains parameters of the Repository.CreateTask
type RepositoryMockCreateTaskParams struct {
	ctx context.Context
	t1  models.Task
}

// RepositoryMockCreateTaskResults contains results of the Repository.CreateTask
type RepositoryMockCreateTaskResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for Repository.CreateTask
func (mmCreateTask *mRepositoryMockCreateTask) Expect(ctx context.Context, t1 models.Task) *mRepositoryMockCreateTask {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("RepositoryMock.CreateTask mock is already set by Set")
	}

	if mmCreateTask.defaultExpectation == nil {
		mmCreateTask.defaultExpectation = &RepositoryMockCreateTaskExpectation{}
	}

	mmCreateTask.defaultExpectation.params = &RepositoryMockCreateTaskParams{ctx, t1}
	for _, e := range mmCreateTask.expectations {
		if minimock.Equal(e.params, mmCreateTask.defaultExpectation.params) {
			mmCreateTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTask.defaultExpectation.params)
		}
	}

	return mmCreateTask
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateTask
func (mmCreateTask *mRepositoryMockCreateTask) Inspect(f func(ctx context.Context, t1 models.Task)) *mRepositoryMockCreateTask {
	if mmCreateTask.mock.inspectFuncCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateTask")
	}

	mmCreateTask.mock.inspectFuncCreateTask = f

	return mmCreateTask
}

// Return sets up results that will be returned by Repository.CreateTask
func (mmCreateTask *mRepositoryMockCreateTask) Return(u1 uint64, err error) *RepositoryMock {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("RepositoryMock.CreateTask mock is already set by Set")
	}

	if mmCreateTask.defaultExpectation == nil {
		mmCreateTask.defaultExpectation = &RepositoryMockCreateTaskExpectation{mock: mmCreateTask.mock}
	}
	mmCreateTask.defaultExpectation.results = &RepositoryMockCreateTaskResults{u1, err}
	return mmCreateTask.mock
}

//Set uses given function f to mock the Repository.CreateTask method
func (mmCreateTask *mRepositoryMockCreateTask) Set(f func(ctx context.Context, t1 models.Task) (u1 uint64, err error)) *RepositoryMock {
	if mmCreateTask.defaultExpectation != nil {
		mmCreateTask.mock.t.Fatalf("Default expectation is already set for the Repository.CreateTask method")
	}

	if len(mmCreateTask.expectations) > 0 {
		mmCreateTask.mock.t.Fatalf("Some expectations are already set for the Repository.CreateTask method")
	}

	mmCreateTask.mock.funcCreateTask = f
	return mmCreateTask.mock
}

// When sets expectation for the Repository.CreateTask which will trigger the result defined by the following
// Then helper
func (mmCreateTask *mRepositoryMockCreateTask) When(ctx context.Context, t1 models.Task) *RepositoryMockCreateTaskExpectation {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("RepositoryMock.CreateTask mock is already set by Set")
	}

	expectation := &RepositoryMockCreateTaskExpectation{
		mock:   mmCreateTask.mock,
		params: &RepositoryMockCreateTaskParams{ctx, t1},
	}
	mmCreateTask.expectations = append(mmCreateTask.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateTask return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateTaskExpectation) Then(u1 uint64, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateTaskResults{u1, err}
	return e.mock
}

// CreateTask implements Repository
func (mmCreateTask *RepositoryMock) CreateTask(ctx context.Context, t1 models.Task) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmCreateTask.beforeCreateTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTask.afterCreateTaskCounter, 1)

	if mmCreateTask.inspectFuncCreateTask != nil {
		mmCreateTask.inspectFuncCreateTask(ctx, t1)
	}

	mm_params := &RepositoryMockCreateTaskParams{ctx, t1}

	// Record call args
	mmCreateTask.CreateTaskMock.mutex.Lock()
	mmCreateTask.CreateTaskMock.callArgs = append(mmCreateTask.CreateTaskMock.callArgs, mm_params)
	mmCreateTask.CreateTaskMock.mutex.Unlock()

	for _, e := range mmCreateTask.CreateTaskMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreateTask.CreateTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTask.CreateTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTask.CreateTaskMock.defaultExpectation.params
		mm_got := RepositoryMockCreateTaskParams{ctx, t1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTask.t.Errorf("RepositoryMock.CreateTask got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTask.CreateTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTask.t.Fatal("No results are set for the RepositoryMock.CreateTask")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreateTask.funcCreateTask != nil {
		return mmCreateTask.funcCreateTask(ctx, t1)
	}
	mmCreateTask.t.Fatalf("Unexpected call to RepositoryMock.CreateTask. %v %v", ctx, t1)
	return
}

// CreateTaskAfterCounter returns a count of finished RepositoryMock.CreateTask invocations
func (mmCreateTask *RepositoryMock) CreateTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTask.afterCreateTaskCounter)
}

// CreateTaskBeforeCounter returns a count of RepositoryMock.CreateTask invocations
func (mmCreateTask *RepositoryMock) CreateTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTask.beforeCreateTaskCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTask *mRepositoryMockCreateTask) Calls() []*RepositoryMockCreateTaskParams {
	mmCreateTask.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateTaskParams, len(mmCreateTask.callArgs))
	copy(argCopy, mmCreateTask.callArgs)

	mmCreateTask.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTaskDone returns true if the count of the CreateTask invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateTaskDone() bool {
	for _, e := range m.CreateTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateTaskCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTask != nil && mm_atomic.LoadUint64(&m.afterCreateTaskCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateTaskInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateTaskInspect() {
	for _, e := range m.CreateTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateTask with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateTaskCounter) < 1 {
		if m.CreateTaskMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateTask")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateTask with params: %#v", *m.CreateTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTask != nil && mm_atomic.LoadUint64(&m.afterCreateTaskCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateTask")
	}
}

type mRepositoryMockCreateTaskStage struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateTaskStageExpectation
	expectations       []*RepositoryMockCreateTaskStageExpectation

	callArgs []*RepositoryMockCreateTaskStageParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateTaskStageExpectation specifies expectation struct of the Repository.CreateTaskStage
type RepositoryMockCreateTaskStageExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateTaskStageParams
	results *RepositoryMockCreateTaskStageResults
	Counter uint64
}

// RepositoryMockCreateTaskStageParams contains parameters of the Repository.CreateTaskStage
type RepositoryMockCreateTaskStageParams struct {
	ctx       context.Context
	taskStage models.TaskStage
	taskID    uint64
}

// RepositoryMockCreateTaskStageResults contains results of the Repository.CreateTaskStage
type RepositoryMockCreateTaskStageResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for Repository.CreateTaskStage
func (mmCreateTaskStage *mRepositoryMockCreateTaskStage) Expect(ctx context.Context, taskStage models.TaskStage, taskID uint64) *mRepositoryMockCreateTaskStage {
	if mmCreateTaskStage.mock.funcCreateTaskStage != nil {
		mmCreateTaskStage.mock.t.Fatalf("RepositoryMock.CreateTaskStage mock is already set by Set")
	}

	if mmCreateTaskStage.defaultExpectation == nil {
		mmCreateTaskStage.defaultExpectation = &RepositoryMockCreateTaskStageExpectation{}
	}

	mmCreateTaskStage.defaultExpectation.params = &RepositoryMockCreateTaskStageParams{ctx, taskStage, taskID}
	for _, e := range mmCreateTaskStage.expectations {
		if minimock.Equal(e.params, mmCreateTaskStage.defaultExpectation.params) {
			mmCreateTaskStage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTaskStage.defaultExpectation.params)
		}
	}

	return mmCreateTaskStage
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateTaskStage
func (mmCreateTaskStage *mRepositoryMockCreateTaskStage) Inspect(f func(ctx context.Context, taskStage models.TaskStage, taskID uint64)) *mRepositoryMockCreateTaskStage {
	if mmCreateTaskStage.mock.inspectFuncCreateTaskStage != nil {
		mmCreateTaskStage.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateTaskStage")
	}

	mmCreateTaskStage.mock.inspectFuncCreateTaskStage = f

	return mmCreateTaskStage
}

// Return sets up results that will be returned by Repository.CreateTaskStage
func (mmCreateTaskStage *mRepositoryMockCreateTaskStage) Return(u1 uint64, err error) *RepositoryMock {
	if mmCreateTaskStage.mock.funcCreateTaskStage != nil {
		mmCreateTaskStage.mock.t.Fatalf("RepositoryMock.CreateTaskStage mock is already set by Set")
	}

	if mmCreateTaskStage.defaultExpectation == nil {
		mmCreateTaskStage.defaultExpectation = &RepositoryMockCreateTaskStageExpectation{mock: mmCreateTaskStage.mock}
	}
	mmCreateTaskStage.defaultExpectation.results = &RepositoryMockCreateTaskStageResults{u1, err}
	return mmCreateTaskStage.mock
}

//Set uses given function f to mock the Repository.CreateTaskStage method
func (mmCreateTaskStage *mRepositoryMockCreateTaskStage) Set(f func(ctx context.Context, taskStage models.TaskStage, taskID uint64) (u1 uint64, err error)) *RepositoryMock {
	if mmCreateTaskStage.defaultExpectation != nil {
		mmCreateTaskStage.mock.t.Fatalf("Default expectation is already set for the Repository.CreateTaskStage method")
	}

	if len(mmCreateTaskStage.expectations) > 0 {
		mmCreateTaskStage.mock.t.Fatalf("Some expectations are already set for the Repository.CreateTaskStage method")
	}

	mmCreateTaskStage.mock.funcCreateTaskStage = f
	return mmCreateTaskStage.mock
}

// When sets expectation for the Repository.CreateTaskStage which will trigger the result defined by the following
// Then helper
func (mmCreateTaskStage *mRepositoryMockCreateTaskStage) When(ctx context.Context, taskStage models.TaskStage, taskID uint64) *RepositoryMockCreateTaskStageExpectation {
	if mmCreateTaskStage.mock.funcCreateTaskStage != nil {
		mmCreateTaskStage.mock.t.Fatalf("RepositoryMock.CreateTaskStage mock is already set by Set")
	}

	expectation := &RepositoryMockCreateTaskStageExpectation{
		mock:   mmCreateTaskStage.mock,
		params: &RepositoryMockCreateTaskStageParams{ctx, taskStage, taskID},
	}
	mmCreateTaskStage.expectations = append(mmCreateTaskStage.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateTaskStage return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateTaskStageExpectation) Then(u1 uint64, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateTaskStageResults{u1, err}
	return e.mock
}

// CreateTaskStage implements Repository
func (mmCreateTaskStage *RepositoryMock) CreateTaskStage(ctx context.Context, taskStage models.TaskStage, taskID uint64) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmCreateTaskStage.beforeCreateTaskStageCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTaskStage.afterCreateTaskStageCounter, 1)

	if mmCreateTaskStage.inspectFuncCreateTaskStage != nil {
		mmCreateTaskStage.inspectFuncCreateTaskStage(ctx, taskStage, taskID)
	}

	mm_params := &RepositoryMockCreateTaskStageParams{ctx, taskStage, taskID}

	// Record call args
	mmCreateTaskStage.CreateTaskStageMock.mutex.Lock()
	mmCreateTaskStage.CreateTaskStageMock.callArgs = append(mmCreateTaskStage.CreateTaskStageMock.callArgs, mm_params)
	mmCreateTaskStage.CreateTaskStageMock.mutex.Unlock()

	for _, e := range mmCreateTaskStage.CreateTaskStageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreateTaskStage.CreateTaskStageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTaskStage.CreateTaskStageMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTaskStage.CreateTaskStageMock.defaultExpectation.params
		mm_got := RepositoryMockCreateTaskStageParams{ctx, taskStage, taskID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTaskStage.t.Errorf("RepositoryMock.CreateTaskStage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTaskStage.CreateTaskStageMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTaskStage.t.Fatal("No results are set for the RepositoryMock.CreateTaskStage")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreateTaskStage.funcCreateTaskStage != nil {
		return mmCreateTaskStage.funcCreateTaskStage(ctx, taskStage, taskID)
	}
	mmCreateTaskStage.t.Fatalf("Unexpected call to RepositoryMock.CreateTaskStage. %v %v %v", ctx, taskStage, taskID)
	return
}

// CreateTaskStageAfterCounter returns a count of finished RepositoryMock.CreateTaskStage invocations
func (mmCreateTaskStage *RepositoryMock) CreateTaskStageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTaskStage.afterCreateTaskStageCounter)
}

// CreateTaskStageBeforeCounter returns a count of RepositoryMock.CreateTaskStage invocations
func (mmCreateTaskStage *RepositoryMock) CreateTaskStageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTaskStage.beforeCreateTaskStageCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateTaskStage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTaskStage *mRepositoryMockCreateTaskStage) Calls() []*RepositoryMockCreateTaskStageParams {
	mmCreateTaskStage.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateTaskStageParams, len(mmCreateTaskStage.callArgs))
	copy(argCopy, mmCreateTaskStage.callArgs)

	mmCreateTaskStage.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTaskStageDone returns true if the count of the CreateTaskStage invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateTaskStageDone() bool {
	for _, e := range m.CreateTaskStageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTaskStageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateTaskStageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTaskStage != nil && mm_atomic.LoadUint64(&m.afterCreateTaskStageCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateTaskStageInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateTaskStageInspect() {
	for _, e := range m.CreateTaskStageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateTaskStage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTaskStageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateTaskStageCounter) < 1 {
		if m.CreateTaskStageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateTaskStage")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateTaskStage with params: %#v", *m.CreateTaskStageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTaskStage != nil && mm_atomic.LoadUint64(&m.afterCreateTaskStageCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateTaskStage")
	}
}

type mRepositoryMockCreateUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateUserExpectation
	expectations       []*RepositoryMockCreateUserExpectation

	callArgs []*RepositoryMockCreateUserParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateUserExpectation specifies expectation struct of the Repository.CreateUser
type RepositoryMockCreateUserExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateUserParams
	results *RepositoryMockCreateUserResults
	Counter uint64
}

// RepositoryMockCreateUserParams contains parameters of the Repository.CreateUser
type RepositoryMockCreateUserParams struct {
	ctx context.Context
}

// RepositoryMockCreateUserResults contains results of the Repository.CreateUser
type RepositoryMockCreateUserResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Expect(ctx context.Context) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{}
	}

	mmCreateUser.defaultExpectation.params = &RepositoryMockCreateUserParams{ctx}
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Inspect(f func(ctx context.Context)) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Return(u1 uint64, err error) *RepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &RepositoryMockCreateUserResults{u1, err}
	return mmCreateUser.mock
}

//Set uses given function f to mock the Repository.CreateUser method
func (mmCreateUser *mRepositoryMockCreateUser) Set(f func(ctx context.Context) (u1 uint64, err error)) *RepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the Repository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the Repository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	return mmCreateUser.mock
}

// When sets expectation for the Repository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mRepositoryMockCreateUser) When(ctx context.Context) *RepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &RepositoryMockCreateUserExpectation{
		mock:   mmCreateUser.mock,
		params: &RepositoryMockCreateUserParams{ctx},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateUserExpectation) Then(u1 uint64, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateUserResults{u1, err}
	return e.mock
}

// CreateUser implements Repository
func (mmCreateUser *RepositoryMock) CreateUser(ctx context.Context) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx)
	}

	mm_params := &RepositoryMockCreateUserParams{ctx}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_got := RepositoryMockCreateUserParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("RepositoryMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the RepositoryMock.CreateUser")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx)
	}
	mmCreateUser.t.Fatalf("Unexpected call to RepositoryMock.CreateUser. %v", ctx)
	return
}

// CreateUserAfterCounter returns a count of finished RepositoryMock.CreateUser invocations
func (mmCreateUser *RepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of RepositoryMock.CreateUser invocations
func (mmCreateUser *RepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mRepositoryMockCreateUser) Calls() []*RepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateUserDone() bool {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateUser")
	}
}

type mRepositoryMockGetAllTasks struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetAllTasksExpectation
	expectations       []*RepositoryMockGetAllTasksExpectation

	callArgs []*RepositoryMockGetAllTasksParams
	mutex    sync.RWMutex
}

// RepositoryMockGetAllTasksExpectation specifies expectation struct of the Repository.GetAllTasks
type RepositoryMockGetAllTasksExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetAllTasksParams
	results *RepositoryMockGetAllTasksResults
	Counter uint64
}

// RepositoryMockGetAllTasksParams contains parameters of the Repository.GetAllTasks
type RepositoryMockGetAllTasksParams struct {
	ctx context.Context
}

// RepositoryMockGetAllTasksResults contains results of the Repository.GetAllTasks
type RepositoryMockGetAllTasksResults struct {
	tpa1 []*models.Task
	err  error
}

// Expect sets up expected params for Repository.GetAllTasks
func (mmGetAllTasks *mRepositoryMockGetAllTasks) Expect(ctx context.Context) *mRepositoryMockGetAllTasks {
	if mmGetAllTasks.mock.funcGetAllTasks != nil {
		mmGetAllTasks.mock.t.Fatalf("RepositoryMock.GetAllTasks mock is already set by Set")
	}

	if mmGetAllTasks.defaultExpectation == nil {
		mmGetAllTasks.defaultExpectation = &RepositoryMockGetAllTasksExpectation{}
	}

	mmGetAllTasks.defaultExpectation.params = &RepositoryMockGetAllTasksParams{ctx}
	for _, e := range mmGetAllTasks.expectations {
		if minimock.Equal(e.params, mmGetAllTasks.defaultExpectation.params) {
			mmGetAllTasks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllTasks.defaultExpectation.params)
		}
	}

	return mmGetAllTasks
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetAllTasks
func (mmGetAllTasks *mRepositoryMockGetAllTasks) Inspect(f func(ctx context.Context)) *mRepositoryMockGetAllTasks {
	if mmGetAllTasks.mock.inspectFuncGetAllTasks != nil {
		mmGetAllTasks.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetAllTasks")
	}

	mmGetAllTasks.mock.inspectFuncGetAllTasks = f

	return mmGetAllTasks
}

// Return sets up results that will be returned by Repository.GetAllTasks
func (mmGetAllTasks *mRepositoryMockGetAllTasks) Return(tpa1 []*models.Task, err error) *RepositoryMock {
	if mmGetAllTasks.mock.funcGetAllTasks != nil {
		mmGetAllTasks.mock.t.Fatalf("RepositoryMock.GetAllTasks mock is already set by Set")
	}

	if mmGetAllTasks.defaultExpectation == nil {
		mmGetAllTasks.defaultExpectation = &RepositoryMockGetAllTasksExpectation{mock: mmGetAllTasks.mock}
	}
	mmGetAllTasks.defaultExpectation.results = &RepositoryMockGetAllTasksResults{tpa1, err}
	return mmGetAllTasks.mock
}

//Set uses given function f to mock the Repository.GetAllTasks method
func (mmGetAllTasks *mRepositoryMockGetAllTasks) Set(f func(ctx context.Context) (tpa1 []*models.Task, err error)) *RepositoryMock {
	if mmGetAllTasks.defaultExpectation != nil {
		mmGetAllTasks.mock.t.Fatalf("Default expectation is already set for the Repository.GetAllTasks method")
	}

	if len(mmGetAllTasks.expectations) > 0 {
		mmGetAllTasks.mock.t.Fatalf("Some expectations are already set for the Repository.GetAllTasks method")
	}

	mmGetAllTasks.mock.funcGetAllTasks = f
	return mmGetAllTasks.mock
}

// When sets expectation for the Repository.GetAllTasks which will trigger the result defined by the following
// Then helper
func (mmGetAllTasks *mRepositoryMockGetAllTasks) When(ctx context.Context) *RepositoryMockGetAllTasksExpectation {
	if mmGetAllTasks.mock.funcGetAllTasks != nil {
		mmGetAllTasks.mock.t.Fatalf("RepositoryMock.GetAllTasks mock is already set by Set")
	}

	expectation := &RepositoryMockGetAllTasksExpectation{
		mock:   mmGetAllTasks.mock,
		params: &RepositoryMockGetAllTasksParams{ctx},
	}
	mmGetAllTasks.expectations = append(mmGetAllTasks.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetAllTasks return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetAllTasksExpectation) Then(tpa1 []*models.Task, err error) *RepositoryMock {
	e.results = &RepositoryMockGetAllTasksResults{tpa1, err}
	return e.mock
}

// GetAllTasks implements Repository
func (mmGetAllTasks *RepositoryMock) GetAllTasks(ctx context.Context) (tpa1 []*models.Task, err error) {
	mm_atomic.AddUint64(&mmGetAllTasks.beforeGetAllTasksCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllTasks.afterGetAllTasksCounter, 1)

	if mmGetAllTasks.inspectFuncGetAllTasks != nil {
		mmGetAllTasks.inspectFuncGetAllTasks(ctx)
	}

	mm_params := &RepositoryMockGetAllTasksParams{ctx}

	// Record call args
	mmGetAllTasks.GetAllTasksMock.mutex.Lock()
	mmGetAllTasks.GetAllTasksMock.callArgs = append(mmGetAllTasks.GetAllTasksMock.callArgs, mm_params)
	mmGetAllTasks.GetAllTasksMock.mutex.Unlock()

	for _, e := range mmGetAllTasks.GetAllTasksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tpa1, e.results.err
		}
	}

	if mmGetAllTasks.GetAllTasksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllTasks.GetAllTasksMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllTasks.GetAllTasksMock.defaultExpectation.params
		mm_got := RepositoryMockGetAllTasksParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllTasks.t.Errorf("RepositoryMock.GetAllTasks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllTasks.GetAllTasksMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllTasks.t.Fatal("No results are set for the RepositoryMock.GetAllTasks")
		}
		return (*mm_results).tpa1, (*mm_results).err
	}
	if mmGetAllTasks.funcGetAllTasks != nil {
		return mmGetAllTasks.funcGetAllTasks(ctx)
	}
	mmGetAllTasks.t.Fatalf("Unexpected call to RepositoryMock.GetAllTasks. %v", ctx)
	return
}

// GetAllTasksAfterCounter returns a count of finished RepositoryMock.GetAllTasks invocations
func (mmGetAllTasks *RepositoryMock) GetAllTasksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllTasks.afterGetAllTasksCounter)
}

// GetAllTasksBeforeCounter returns a count of RepositoryMock.GetAllTasks invocations
func (mmGetAllTasks *RepositoryMock) GetAllTasksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllTasks.beforeGetAllTasksCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetAllTasks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllTasks *mRepositoryMockGetAllTasks) Calls() []*RepositoryMockGetAllTasksParams {
	mmGetAllTasks.mutex.RLock()

	argCopy := make([]*RepositoryMockGetAllTasksParams, len(mmGetAllTasks.callArgs))
	copy(argCopy, mmGetAllTasks.callArgs)

	mmGetAllTasks.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllTasksDone returns true if the count of the GetAllTasks invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetAllTasksDone() bool {
	for _, e := range m.GetAllTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllTasksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllTasksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllTasks != nil && mm_atomic.LoadUint64(&m.afterGetAllTasksCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAllTasksInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetAllTasksInspect() {
	for _, e := range m.GetAllTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetAllTasks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllTasksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllTasksCounter) < 1 {
		if m.GetAllTasksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetAllTasks")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetAllTasks with params: %#v", *m.GetAllTasksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllTasks != nil && mm_atomic.LoadUint64(&m.afterGetAllTasksCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetAllTasks")
	}
}

type mRepositoryMockGetTask struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetTaskExpectation
	expectations       []*RepositoryMockGetTaskExpectation

	callArgs []*RepositoryMockGetTaskParams
	mutex    sync.RWMutex
}

// RepositoryMockGetTaskExpectation specifies expectation struct of the Repository.GetTask
type RepositoryMockGetTaskExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetTaskParams
	results *RepositoryMockGetTaskResults
	Counter uint64
}

// RepositoryMockGetTaskParams contains parameters of the Repository.GetTask
type RepositoryMockGetTaskParams struct {
	ctx context.Context
	ID  uint64
}

// RepositoryMockGetTaskResults contains results of the Repository.GetTask
type RepositoryMockGetTaskResults struct {
	tp1 *models.Task
	err error
}

// Expect sets up expected params for Repository.GetTask
func (mmGetTask *mRepositoryMockGetTask) Expect(ctx context.Context, ID uint64) *mRepositoryMockGetTask {
	if mmGetTask.mock.funcGetTask != nil {
		mmGetTask.mock.t.Fatalf("RepositoryMock.GetTask mock is already set by Set")
	}

	if mmGetTask.defaultExpectation == nil {
		mmGetTask.defaultExpectation = &RepositoryMockGetTaskExpectation{}
	}

	mmGetTask.defaultExpectation.params = &RepositoryMockGetTaskParams{ctx, ID}
	for _, e := range mmGetTask.expectations {
		if minimock.Equal(e.params, mmGetTask.defaultExpectation.params) {
			mmGetTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTask.defaultExpectation.params)
		}
	}

	return mmGetTask
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetTask
func (mmGetTask *mRepositoryMockGetTask) Inspect(f func(ctx context.Context, ID uint64)) *mRepositoryMockGetTask {
	if mmGetTask.mock.inspectFuncGetTask != nil {
		mmGetTask.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetTask")
	}

	mmGetTask.mock.inspectFuncGetTask = f

	return mmGetTask
}

// Return sets up results that will be returned by Repository.GetTask
func (mmGetTask *mRepositoryMockGetTask) Return(tp1 *models.Task, err error) *RepositoryMock {
	if mmGetTask.mock.funcGetTask != nil {
		mmGetTask.mock.t.Fatalf("RepositoryMock.GetTask mock is already set by Set")
	}

	if mmGetTask.defaultExpectation == nil {
		mmGetTask.defaultExpectation = &RepositoryMockGetTaskExpectation{mock: mmGetTask.mock}
	}
	mmGetTask.defaultExpectation.results = &RepositoryMockGetTaskResults{tp1, err}
	return mmGetTask.mock
}

//Set uses given function f to mock the Repository.GetTask method
func (mmGetTask *mRepositoryMockGetTask) Set(f func(ctx context.Context, ID uint64) (tp1 *models.Task, err error)) *RepositoryMock {
	if mmGetTask.defaultExpectation != nil {
		mmGetTask.mock.t.Fatalf("Default expectation is already set for the Repository.GetTask method")
	}

	if len(mmGetTask.expectations) > 0 {
		mmGetTask.mock.t.Fatalf("Some expectations are already set for the Repository.GetTask method")
	}

	mmGetTask.mock.funcGetTask = f
	return mmGetTask.mock
}

// When sets expectation for the Repository.GetTask which will trigger the result defined by the following
// Then helper
func (mmGetTask *mRepositoryMockGetTask) When(ctx context.Context, ID uint64) *RepositoryMockGetTaskExpectation {
	if mmGetTask.mock.funcGetTask != nil {
		mmGetTask.mock.t.Fatalf("RepositoryMock.GetTask mock is already set by Set")
	}

	expectation := &RepositoryMockGetTaskExpectation{
		mock:   mmGetTask.mock,
		params: &RepositoryMockGetTaskParams{ctx, ID},
	}
	mmGetTask.expectations = append(mmGetTask.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetTask return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetTaskExpectation) Then(tp1 *models.Task, err error) *RepositoryMock {
	e.results = &RepositoryMockGetTaskResults{tp1, err}
	return e.mock
}

// GetTask implements Repository
func (mmGetTask *RepositoryMock) GetTask(ctx context.Context, ID uint64) (tp1 *models.Task, err error) {
	mm_atomic.AddUint64(&mmGetTask.beforeGetTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTask.afterGetTaskCounter, 1)

	if mmGetTask.inspectFuncGetTask != nil {
		mmGetTask.inspectFuncGetTask(ctx, ID)
	}

	mm_params := &RepositoryMockGetTaskParams{ctx, ID}

	// Record call args
	mmGetTask.GetTaskMock.mutex.Lock()
	mmGetTask.GetTaskMock.callArgs = append(mmGetTask.GetTaskMock.callArgs, mm_params)
	mmGetTask.GetTaskMock.mutex.Unlock()

	for _, e := range mmGetTask.GetTaskMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmGetTask.GetTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTask.GetTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTask.GetTaskMock.defaultExpectation.params
		mm_got := RepositoryMockGetTaskParams{ctx, ID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTask.t.Errorf("RepositoryMock.GetTask got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTask.GetTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTask.t.Fatal("No results are set for the RepositoryMock.GetTask")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmGetTask.funcGetTask != nil {
		return mmGetTask.funcGetTask(ctx, ID)
	}
	mmGetTask.t.Fatalf("Unexpected call to RepositoryMock.GetTask. %v %v", ctx, ID)
	return
}

// GetTaskAfterCounter returns a count of finished RepositoryMock.GetTask invocations
func (mmGetTask *RepositoryMock) GetTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTask.afterGetTaskCounter)
}

// GetTaskBeforeCounter returns a count of RepositoryMock.GetTask invocations
func (mmGetTask *RepositoryMock) GetTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTask.beforeGetTaskCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTask *mRepositoryMockGetTask) Calls() []*RepositoryMockGetTaskParams {
	mmGetTask.mutex.RLock()

	argCopy := make([]*RepositoryMockGetTaskParams, len(mmGetTask.callArgs))
	copy(argCopy, mmGetTask.callArgs)

	mmGetTask.mutex.RUnlock()

	return argCopy
}

// MinimockGetTaskDone returns true if the count of the GetTask invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetTaskDone() bool {
	for _, e := range m.GetTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTaskCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTask != nil && mm_atomic.LoadUint64(&m.afterGetTaskCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetTaskInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetTaskInspect() {
	for _, e := range m.GetTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetTask with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTaskCounter) < 1 {
		if m.GetTaskMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetTask")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetTask with params: %#v", *m.GetTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTask != nil && mm_atomic.LoadUint64(&m.afterGetTaskCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetTask")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateTaskInspect()

		m.MinimockCreateTaskStageInspect()

		m.MinimockCreateUserInspect()

		m.MinimockGetAllTasksInspect()

		m.MinimockGetTaskInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateTaskDone() &&
		m.MinimockCreateTaskStageDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockGetAllTasksDone() &&
		m.MinimockGetTaskDone()
}
